/*
  Copyright (c) 2018, Sylabs, Inc. All rights reserved.

  This software is licensed under a 3-clause BSD license.  Please
  consult LICENSE file distributed with the sources of this project regarding
  your rights to use or distribute this software.
*/


#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <unistd.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <fcntl.h>
#include <poll.h>
#include <grp.h>
#include <link.h>
#include <limits.h>
#include <sys/fsuid.h>
#include <sys/mount.h>
#include <sys/wait.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <signal.h>
#include <sched.h>
#include <sys/socket.h>
#include <setjmp.h>
#include <sys/syscall.h>

#ifdef SINGULARITY_SECUREBITS
#  include <linux/securebits.h>
#else
#  include "c/lib/util/securebits.h"
#endif /* SINGULARITY_SECUREBITS */

#include "c/lib/util/capability.h"
#include "c/lib/util/message.h"
#include "c/lib/util/util.h"

#include "startup/c/wrapper.h"

// generated by GO libstartup build
#include "lib/libstartup.h"

#define CLONE_STACK_SIZE    1024*1024
#define BUFSIZE             512

extern char **environ;

/* C and JSON configuration */
struct cConfig config;
char *json_stdin;

/* Socket process communication */
int rpc_socket[2];
int stage_socket[2];

#define SCONTAINER_STAGE1   1
#define SCONTAINER_STAGE2   2
#define SCONTAINER_STAGE3   3
#define SMASTER             4
#define RPC_SERVER          5

unsigned char execute = SCONTAINER_STAGE1;
pid_t stage_pid;
char *sruntime;

typedef struct fork_state_s {
    sigjmp_buf env;
} fork_state_t;

/* copy paste from singularity code */
static int clone_fn(void *data_ptr) {
    fork_state_t *state = (fork_state_t *)data_ptr;
    siglongjmp(state->env, 1);
}

static int fork_ns(unsigned int flags) {
    fork_state_t state;

    if ( sigsetjmp(state.env, 1) ) {
        return 0;
    }

    int stack_size = CLONE_STACK_SIZE;
    char *child_stack_ptr = malloc(stack_size);
    if ( child_stack_ptr == 0 ) {
        errno = ENOMEM;
        return -1;
    }
    child_stack_ptr += stack_size;

    int retval = clone(clone_fn, child_stack_ptr, (SIGCHLD|flags), &state);
    return retval;
}

static void priv_escalate(void) {
    singularity_message(VERBOSE, "Get root privileges\n");
    if ( seteuid(0) < 0 ) {
        singularity_message(ERROR, "Failed to set effective UID to 0\n");
        exit(1);
    }
}

static void set_parent_death_signal(int signo) {
    singularity_message(DEBUG, "Set parent death signal to %d\n", signo);
    if ( prctl(PR_SET_PDEATHSIG, signo) < 0 ) {
        singularity_message(ERROR, "Failed to set parent death signal\n");
        exit(1);
    }
}

static void prepare_scontainer_stage(int stage) {
    uid_t uid = getuid();
    struct __user_cap_header_struct header;
    struct __user_cap_data_struct data[2];

    set_parent_death_signal(SIGKILL);

    singularity_message(DEBUG, "Entering in scontainer stage %d\n", stage);

    if ( stage == 2 ) {
        execute = SCONTAINER_STAGE2;
        if ( config.mntPid == 0 ) {
            stage_pid = fork();
            if ( stage_pid == 0 ) {
                execute = SCONTAINER_STAGE3;
            }
        }
    }

    if ( stage_pid < 0 ) {
        singularity_message(ERROR, "Failed to spawn child: %s\n", strerror(errno));
        exit(1);
    }

    if ( config.nsFlags & CLONE_NEWUSER || config.isSuid == 0 ) {
        return;
    }

    header.version = LINUX_CAPABILITY_VERSION;
    header.pid = 0;

    if ( capget(&header, data) < 0 ) {
        singularity_message(ERROR, "Failed to get processus capabilities\n");
        exit(1);
    }

    if ( stage_pid > 0 ) {
        data[1].inheritable = (__u32)(config.capInheritable >> 32);
        data[0].inheritable = (__u32)(config.capInheritable & 0xFFFFFFFF);
        data[1].permitted = (__u32)(config.capPermitted >> 32);
        data[0].permitted = (__u32)(config.capPermitted & 0xFFFFFFFF);
        data[1].effective = (__u32)(config.capEffective >> 32);
        data[0].effective = (__u32)(config.capEffective & 0xFFFFFFFF);
    } else {
        data[1].inheritable = data[1].permitted = data[1].effective = 0;
        data[0].inheritable = data[0].permitted = data[0].effective = 0;
        config.capBounding = 0;
        config.capAmbient = 0;
    }

    if ( prctl(PR_SET_SECUREBITS, SECBIT_NO_SETUID_FIXUP|SECBIT_NO_SETUID_FIXUP_LOCKED) < 0 ) {
        singularity_message(ERROR, "Failed to set securebits: %s\n", strerror(errno));
        exit(1);
    }

    if ( setresuid(uid, uid, uid) < 0 ) {
        singularity_message(ERROR, "Faile to drop privileges: %s\n", strerror(errno));
        exit(1);
    }

    set_parent_death_signal(SIGKILL);

    int last_cap;
    for ( last_cap = CAPSET_MAX; ; last_cap-- ) {
        if ( prctl(PR_CAPBSET_READ, last_cap) > 0 || last_cap == 0 ) {
            break;
        }
    }

    int caps_index;
    for ( caps_index = 0; caps_index <= last_cap; caps_index++ ) {
        if ( !(config.capBounding & (1ULL << caps_index)) ) {
            if ( prctl(PR_CAPBSET_DROP, caps_index) < 0 ) {
                singularity_message(ERROR, "Failed to drop bounding capabilities set: %s\n", strerror(errno));
                exit(1);
            }
        }
    }

#ifdef SINGULARITY_NO_NEW_PRIVS
    if ( config.noNewPrivs ) {
        if ( prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0 ) {
            singularity_message(ERROR, "Failed to set no new privs flag: %s\n", strerror(errno));
            exit(1);
        }
    }
#endif

    if ( capset(&header, data) < 0 ) {
        singularity_message(ERROR, "Failed to set process capabilities\n");
        exit(1);
    }

#ifdef USER_CAPABILITIES
    // set ambient capabilities if supported
    int i;
    for (i = 0; i <= CAPSET_MAX; i++ ) {
        if ( (config.capAmbient & (1ULL << i)) ) {
            if ( prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, i, 0, 0) < 0 ) {
                singularity_message(ERROR, "Failed to set ambient capability: %s\n", strerror(errno));
                exit(1);
            }
        }
    }
#endif
}

static int create_namespace(int nstype) {
    switch(nstype) {
    case CLONE_NEWNET:
#ifdef NS_CLONE_NEWNET
        singularity_message(VERBOSE, "Create network namespace\n");
#else
        singularity_message(WARNING, "Skipping network namespace creation, not supported\n");
        return(0);
#endif /* NS_CLONE_NEWNET */
        break;
    case CLONE_NEWIPC:
#ifdef NS_CLONE_NEWIPC
        singularity_message(VERBOSE, "Create ipc namespace\n");
#else
        singularity_message(WARNING, "Skipping ipc namespace creation, not supported\n");
        return(0);
#endif /* NS_CLONE_NEWIPC */
        break;
    case CLONE_NEWNS:
#ifdef NS_CLONE_NEWNS
        singularity_message(VERBOSE, "Create mount namespace\n");
#else
        singularity_message(WARNING, "Skipping mount namespace creation, not supported\n");
        return(0);
#endif /* NS_CLONE_NEWNS */
        break;
    case CLONE_NEWUTS:
#ifdef NS_CLONE_NEWUTS
        singularity_message(VERBOSE, "Create uts namespace\n");
#else
        singularity_message(WARNING, "Skipping uts namespace creation, not supported\n");
        return(0);
#endif /* NS_CLONE_NEWUTS */
        break;
    case CLONE_NEWUSER:
#ifdef NS_CLONE_NEWUSER
        singularity_message(VERBOSE, "Create user namespace\n");
#else
        singularity_message(WARNING, "Skipping user namespace creation, not supported\n");
#endif /* NS_CLONE_NEWUSER */
        break;
#ifdef NS_CLONE_NEWCGROUP
    case CLONE_NEWCGROUP:
        singularity_message(VERBOSE, "Create cgroup namespace\n");
        break;
#endif /* NS_CLONE_NEWCGROUP */
    default:
        singularity_message(WARNING, "Skipping unknown namespace creation\n");
        errno = EINVAL;
        return(-1);
    }
    return unshare(nstype);
}

static int enter_namespace(pid_t pid, int nstype) {
    int ns_fd;
    static char buffer[PATH_MAX];
    char *namespace;

    memset(buffer, 0, PATH_MAX);

    switch(nstype) {
    case CLONE_NEWPID:
        singularity_message(VERBOSE, "Entering in pid namespace\n");
#ifdef NS_CLONE_NEWPID
        namespace = strdup("pid");
#else
        errno = EINVAL;
        return(-1);
#endif /* NS_CLONE_NEWPID */
        break;
    case CLONE_NEWNET:
        singularity_message(VERBOSE, "Entering in network namespace\n");
#ifdef NS_CLONE_NEWNET
        namespace = strdup("net");
#else
        errno = EINVAL;
        return(-1);
#endif /* NS_CLONE_NEWNET */
        break;
    case CLONE_NEWIPC:
        singularity_message(VERBOSE, "Entering in ipc namespace\n");
#ifdef NS_CLONE_NEWIPC
        namespace = strdup("ipc");
#else
        errno = EINVAL;
        return(-1);
#endif /* NS_CLONE_NEWIPC */
        break;
    case CLONE_NEWNS:
        singularity_message(VERBOSE, "Entering in mount namespace\n");
#ifdef NS_CLONE_NEWNS
        namespace = strdup("mnt");
#else
        errno = EINVAL;
        return(-1);
#endif /* NS_CLONE_NEWNS */
        break;
    case CLONE_NEWUTS:
        singularity_message(VERBOSE, "Entering in uts namespace\n");
#ifdef NS_CLONE_NEWUTS
        namespace = strdup("uts");
#else
        errno = EINVAL;
        return(-1);
#endif /* NS_CLONE_NEWUTS */
        break;
    case CLONE_NEWUSER:
        singularity_message(VERBOSE, "Entering in user namespace\n");
#ifdef NS_CLONE_NEWUSER
        namespace = strdup("user");
#else
        errno = EINVAL;
        return(-1);
#endif /* NS_CLONE_NEWUSER */
        break;
#ifdef NS_CLONE_NEWCGROUP
    case CLONE_NEWCGROUP:
        singularity_message(VERBOSE, "Entering in cgroup namespace\n");
        namespace = strdup("cgroup");
        break;
#endif /* NS_CLONE_NEWCGROUP */
    default:
        singularity_message(VERBOSE, "Entering in unknown namespace\n");
        errno = EINVAL;
        return(-1);
    }

    snprintf(buffer, PATH_MAX-1, "/proc/%d/ns/%s", pid, namespace);
    singularity_message(DEBUG, "Opening namespace file descriptor %s\n", buffer);
    ns_fd = open(buffer, O_RDONLY);
    if ( ns_fd < 0 ) {
        return(-1);
    }

    if ( setns(ns_fd, nstype) < 0 ) {
        int err = errno;
        close(ns_fd);
        free(namespace);
        errno = err;
        return(-1);
    }

    close(ns_fd);
    free(namespace);
    return(0);
}

static void setup_userns(const struct uidMapping *uidMapping, const struct gidMapping *gidMapping) {
    FILE *map_fp;
    int i;
    struct uidMapping *uidmap;
    struct gidMapping *gidmap;

    singularity_message(VERBOSE, "Create user namespace\n");

    if ( unshare(CLONE_NEWUSER) < 0 ) {
        singularity_message(ERROR, "Failed to create user namespace\n");
        exit(1);
    }

    singularity_message(DEBUG, "Write deny to set group file\n");
    map_fp = fopen("/proc/self/setgroups", "w+"); // Flawfinder: ignore
    if ( map_fp != NULL ) {
        fprintf(map_fp, "deny\n");
        if ( fclose(map_fp) < 0 ) {
            singularity_message(ERROR, "Failed to write deny to setgroup file: %s\n", strerror(errno));
            exit(1);
        }
    } else {
        singularity_message(ERROR, "Could not write info to setgroups: %s\n", strerror(errno));
        exit(1);
    }

    singularity_message(DEBUG, "Write to GID map\n");
    for ( i = 0; i < MAX_ID_MAPPING; i++ ) {
        gidmap = (struct gidMapping *)&gidMapping[i];
        if ( gidmap->size == 0 ) {
            break;
        }
        map_fp = fopen("/proc/self/gid_map", "w+"); // Flawfinder: ignore
        if ( map_fp != NULL ) {
            singularity_message(DEBUG, "Write line '%i %i %i' to gid_map\n", gidmap->containerID, gidmap->hostID, gidmap->size);
            fprintf(map_fp, "%i %i %i\n", gidmap->containerID, gidmap->hostID, gidmap->size);
            if ( fclose(map_fp) < 0 ) {
                singularity_message(ERROR, "Failed to write to GID map: %s\n", strerror(errno));
                exit(1);
            }
        } else {
            singularity_message(ERROR, "Could not write parent info to gid_map: %s\n", strerror(errno));
            exit(1);
        }
    }

    singularity_message(DEBUG, "Write to UID map\n");
    for ( i = 0; i < MAX_ID_MAPPING; i++ ) {
        uidmap = (struct uidMapping *)&uidMapping[i];
        if ( uidmap->size == 0 ) {
            break;
        }
        map_fp = fopen("/proc/self/uid_map", "w+"); // Flawfinder: ignore
        if ( map_fp != NULL ) {
            fprintf(map_fp, "%i %i %i\n", uidmap->containerID, uidmap->hostID, uidmap->size);
            if ( fclose(map_fp) < 0 ) {
                singularity_message(ERROR, "Failed to write to UID map: %s\n", strerror(errno));
                exit(1);
            }
        } else {
            singularity_message(ERROR, "Could not write parent info to uid_map: %s\n", strerror(errno));
            exit(1);
        }
    }
}

static unsigned char is_suid(void) {
    ElfW(auxv_t) *auxv;
    unsigned char suid = 0;
    char *buffer = (char *)malloc(4096);
    int proc_auxv = open("/proc/self/auxv", O_RDONLY);

    singularity_message(VERBOSE, "Check if we are running as setuid\n");

    if ( proc_auxv < 0 ) {
        singularity_message(ERROR, "Cant' open /proc/self/auxv: %s\n", strerror(errno));
        exit(1);
    }

    /* use auxiliary vectors to determine if running privileged */
    memset(buffer, 0, 4096);
    if ( read(proc_auxv, buffer, 4088) < 0 ) {
        singularity_message(ERROR, "Can't read auxiliary vectors: %s\n", strerror(errno));
        exit(1);
    }

    auxv = (ElfW(auxv_t) *)buffer;

    for (; auxv->a_type != AT_NULL; auxv++) {
        if ( auxv->a_type == AT_SECURE ) {
            suid = (int)auxv->a_un.a_val;
            break;
        }
    }

    free(buffer);
    close(proc_auxv);

    return suid;
}

void do_nothing(int sig) {
    (void)sig;
    return;
}

__attribute__((constructor)) static void init(void) {
    char *env[8] = {0};
    uid_t uid = getuid();
    gid_t gid = getgid();
    sigset_t mask;
    char *loglevel;
    char *runtime;
    int output[2];

    loglevel = getenv("SINGULARITY_MESSAGELEVEL");
    if ( loglevel != NULL ) {
        loglevel = strdup(loglevel);
    } else {
        singularity_message(ERROR, "SINGULARITY_MESSAGELEVEL environment variable isn't set\n");
        exit(1);
    }

    runtime = getenv("SRUNTIME");
    if ( runtime != NULL ) {
        sruntime = strdup(runtime);
    } else {
        singularity_message(ERROR, "SRUNTIME environment variable isn't set\n");
        exit(1);
    }

    singularity_message(VERBOSE, "Container runtime\n");

    memset(&config, 0, sizeof(config));

    config.isSuid = is_suid();

    if ( config.isSuid ) {
        singularity_message(DEBUG, "Drop privileges\n");
        if ( setegid(gid) < 0 || seteuid(uid) < 0 ) {
            singularity_message(ERROR, "Failed to drop privileges: %s\n", strerror(errno));
            exit(1);
        }
    }

    /* reset environment variables */
    environ = env;

    if ( loglevel != NULL ) {
        setenv("SINGULARITY_MESSAGELEVEL", loglevel, 1);
        free(loglevel);
    }

#ifdef SINGULARITY_NO_NEW_PRIVS
    singularity_message(DEBUG, "PR_SET_NO_NEW_PRIVS supported\n");
    config.hasNoNewPrivs = 1;
#else
    singularity_message(DEBUG, "PR_SET_NO_NEW_PRIVS not supported\n");
    config.hasNoNewPrivs = 0;
#endif

    /* read json configuration from stdin */
    singularity_message(DEBUG, "Read json configuration from stdin\n");
    int std = open("/proc/self/fd/1", O_RDONLY);

    json_stdin = (char *)malloc(MAX_JSON_SIZE);
    if ( json_stdin == NULL ) {
        singularity_message(ERROR, "Memory allocation failed: %s\n", strerror(errno));
        exit(1);
    }

    memset(json_stdin, 0, MAX_JSON_SIZE);
    if ( ( config.jsonConfSize = read(STDIN_FILENO, json_stdin, MAX_JSON_SIZE - 1) ) <= 0 ) {
        singularity_message(ERROR, "Read JSON configuration from stdin failed: %s\n", strerror(errno));
        exit(1);
    }

    /* back to terminal stdin */
    if ( isatty(std) ) {
        singularity_message(DEBUG, "Run in terminal, restore stdin\n");
        if ( dup2(std, STDIN_FILENO) < 0 ) {
            singularity_message(ERROR, "Failed to restore terminal stdin: %s\n", strerror(errno));
            exit(1);
        }
    }
    close(std);

    fd_cleanup();

    /* block SIGCHLD signal handled later by scontainer/smaster */
    singularity_message(DEBUG, "Set child signal mask\n");
    sigemptyset(&mask);
    sigaddset(&mask, SIGCHLD);
    if (sigprocmask(SIG_SETMASK, &mask, NULL) == -1) {
        singularity_message(ERROR, "Blocked signals error: %s\n", strerror(errno));
        exit(1);
    }

    if ( pipe2(output, 0) < 0 ) {
        singularity_message(ERROR, "Failed to create output process pipes: %s\n", strerror(errno));
        exit(1);
    }

    stage_pid = fork();
    if ( stage_pid == 0 ) {
        set_parent_death_signal(SIGKILL);

        close(output[0]);

        if ( dup2(output[1], STDOUT_FILENO) < 0 ) {
            singularity_message(ERROR, "Failed to create stdout pipe: %s\n", strerror(errno));
            exit(1);
        }
        close(output[1]);

        singularity_message(VERBOSE, "Spawn scontainer stage 1\n");

        /*
         *  stage1 is responsible for singularity configuration file parsing, handle user input,
         *  read capabilities, check what namespaces is required.
         */
        if ( config.isSuid ) {
            priv_escalate();
        }

        prepare_scontainer_stage(1);
        return;
    } else if ( stage_pid > 0 ) {
        pid_t parent = getpid();
        int status;
        struct pollfd fds;

        close(output[1]);

        fds.fd = output[0];
        fds.events = POLLIN;
        fds.revents = 0;

        singularity_message(DEBUG, "Wait C and JSON runtime configuration from scontainer stage 1\n");

        while ( poll(&fds, 1, -1) >= 0 ) {
            if ( fds.revents == POLLIN ) {
                int ret;
                singularity_message(DEBUG, "Receiving configuration from scontainer stage 1\n");
                if ( (ret = read(output[0], &config, sizeof(config))) != sizeof(config) ) {
                    singularity_message(ERROR, "Failed to read C configuration stdout pipe: %s\n", strerror(errno));
                    exit(1);
                }
                if ( config.jsonConfSize >= MAX_JSON_SIZE) {
                    singularity_message(ERROR, "JSON configuration too big\n");
                    exit(1);
                }
                if ( (ret = read(output[0], json_stdin, config.jsonConfSize)) != config.jsonConfSize ) {
                    singularity_message(ERROR, "Failed to read JSON configuration from stdout pipe: %s\n", strerror(errno));
                    exit(1);
                }
                json_stdin[config.jsonConfSize] = '\0';
            }
            break;
        }

        close(output[0]);

        singularity_message(DEBUG, "Wait completion of scontainer stage1\n");
        if ( wait(&status) != stage_pid ) {
            singularity_message(ERROR, "Can't wait child\n");
            exit(1);
        }

        if ( WIFEXITED(status) || WIFSIGNALED(status) ) {
            if ( WEXITSTATUS(status) != 0 ) {
                singularity_message(ERROR, "Child exit with status %d\n", WEXITSTATUS(status));
                exit(WEXITSTATUS(status));
            }
        }

        if ( config.isInstance ) {
            singularity_message(VERBOSE, "Run as instance\n");
            int forked = fork();
            if ( forked == 0 ) {
                int i;
                if ( chdir("/") < 0 ) {
                    singularity_message(ERROR, "Can't change directory to /: %s\n", strerror(errno));
                    exit(1);
                }
                if ( setsid() < 0 ) {
                    singularity_message(ERROR, "Can't set session leader: %s\n", strerror(errno));
                    exit(1);
                }
                umask(0);

                singularity_message(DEBUG, "Close all file descriptor\n");
                for( i = sysconf(_SC_OPEN_MAX); i > 2; i-- ) {
                    close(i);
                }
            } else {
                int status;

                singularity_message(DEBUG, "Wait child process signaling SIGSTOP\n");
                waitpid(forked, &status, WUNTRACED);
                if ( WIFSTOPPED(status) ) {
                    singularity_message(DEBUG, "Send SIGCONT to child process\n");
                    kill(forked, SIGCONT);
                    exit(0);
                }
                if ( WIFEXITED(status) || WIFSIGNALED(status) ) {
                    singularity_message(VERBOSE, "Child process exited with status %d\n", WEXITSTATUS(status));
                    exit(WEXITSTATUS(status));
                }
                exit(1);
            }
        }

        if ( (config.nsFlags & CLONE_NEWUSER) == 0 ) {
            priv_escalate();
        } else {
            if ( config.isSuid ) {
                singularity_message(ERROR, "Running setuid workflow with user namespace is not allowed\n");
                exit(1);
            }
            if ( config.userPid ) {
                if ( enter_namespace(config.userPid, CLONE_NEWUSER) < 0 ) {
                    singularity_message(ERROR, "Failed to enter in user namespace: %s\n", strerror(errno));
                    exit(1);
                }
            } else {
                setup_userns(&config.uidMapping[0], &config.gidMapping[0]);
            }
        }

        singularity_message(DEBUG, "Create socketpair communication between smaster and scontainer\n");
        if ( socketpair(AF_UNIX, SOCK_STREAM, 0, stage_socket) < 0 ) {
            singularity_message(ERROR, "Failed to create communication socket: %s\n", strerror(errno));
            exit(1);
        }

        /* enforce PID namespace if NO_NEW_PRIVS not supported  */
        if ( config.hasNoNewPrivs == 0 ) {
            singularity_message(VERBOSE, "No PR_SET_NO_NEW_PRIVS support, enforcing PID namespace\n");
            config.nsFlags |= CLONE_NEWPID;
        }

        if ( config.mntPid ) {
            if ( enter_namespace(config.mntPid, CLONE_NEWNS) < 0 ) {
                singularity_message(ERROR, "Failed to enter in mount namespace: %s\n", strerror(errno));
                exit(1);
            }
        } else {
            singularity_message(VERBOSE, "Unshare filesystem and create mount namespace\n");
            if ( unshare(CLONE_FS) < 0 ) {
                singularity_message(ERROR, "Failed to unshare filesystem: %s\n", strerror(errno));
                exit(1);
            }
            if ( create_namespace(CLONE_NEWNS) < 0 ) {
                singularity_message(ERROR, "Failed to create mount namespace: %s\n", strerror(errno));
                exit(1);
            }

            if ( mount(NULL, "/", NULL, MS_SHARED|MS_REC, NULL) < 0 ) {
                singularity_message(ERROR, "Failed to propagate as SHARED: %s\n", strerror(errno));
            }
        }
        if ( config.pidPid ) {
            if ( enter_namespace(config.pidPid, CLONE_NEWPID) < 0 ) {
                singularity_message(ERROR, "Failed to enter in pid namespace: %s\n", strerror(errno));
                exit(1);
            }
            stage_pid = fork();
        } else {
            if ( config.nsFlags & CLONE_NEWPID ) {
#ifdef NS_CLONE_NEWPID
                singularity_message(VERBOSE, "Create pid namespace\n");
                stage_pid = fork_ns(CLONE_NEWPID);
#else
                if ( config.hasNoNewPrivs == 0 ) {
                    singularity_message(ERROR, "There is no PR_SET_NO_NEW_PRIVS support and can't create PID namespace\n");
                    exit(1);
                }
                singularity_message(WARNING, "Skipping pid namespace creation, support not available on host\n");
                stage_pid = fork();
#endif /* NS_CLONE_NEWPID */
            } else {
                stage_pid = fork();
            }
        }

        if ( stage_pid == 0 ) {
            /* at this stage we are PID 1 if PID namespace requested */
            pid_t child;

            set_parent_death_signal(SIGKILL);

            singularity_message(VERBOSE, "Spawn scontainer stage 2\n");

            if ( config.netPid ) {
                if ( enter_namespace(config.netPid, CLONE_NEWNET) < 0 ) {
                    singularity_message(ERROR, "Failed to enter in network namespace: %s\n", strerror(errno));
                    exit(1);
                }
            } else {
                if ( config.nsFlags & CLONE_NEWNET ) {
                    if ( create_namespace(CLONE_NEWNET) < 0 ) {
                        singularity_message(ERROR, "Failed to create network namespace: %s\n", strerror(errno));
                        exit(1);
                    }
                }
            }
            if ( config.utsPid ) {
                if ( enter_namespace(config.utsPid, CLONE_NEWUTS) < 0 ) {
                    singularity_message(ERROR, "Failed to enter in uts namespace: %s\n", strerror(errno));
                    exit(1);
                }
            } else {
                if ( config.nsFlags & CLONE_NEWUTS ) {
                    if ( create_namespace(CLONE_NEWUTS) < 0 ) {
                        singularity_message(ERROR, "Failed to create uts namespace: %s\n", strerror(errno));
                        exit(1);
                    }
                }
            }
            if ( config.ipcPid ) {
                if ( enter_namespace(config.ipcPid, CLONE_NEWIPC) < 0 ) {
                    singularity_message(ERROR, "Failed to enter in ipc namespace: %s\n", strerror(errno));
                    exit(1);
                }
            } else {
                if ( config.nsFlags & CLONE_NEWIPC ) {
                    if ( create_namespace(CLONE_NEWIPC) < 0 ) {
                        singularity_message(ERROR, "Failed to create ipc namespace: %s\n", strerror(errno));
                        exit(1);
                    }
                }
            }
#ifdef NS_CLONE_NEWCGROUP
            if ( config.cgroupPid ) {
                if ( enter_namespace(config.cgroupPid, CLONE_NEWCGROUP) < 0 ) {
                    singularity_message(ERROR, "Failed to enter in cgroup namespace: %s\n", strerror(errno));
                    exit(1);
                }
            } else {
                if ( config.nsFlags & CLONE_NEWCGROUP ) {
                    if ( create_namespace(CLONE_NEWCGROUP) < 0 ) {
                        singularity_message(ERROR, "Failed to create cgroup namespace: %s\n", strerror(errno));
                        exit(1);
                    }
                }
            }
#endif /* NS_CLONE_NEWCGROUP */

            singularity_message(DEBUG, "Create RPC socketpair for communication between scontainer and RPC server\n");
            if ( socketpair(AF_UNIX, SOCK_STREAM, 0, rpc_socket) < 0 ) {
                singularity_message(ERROR, "Failed to create communication socket: %s\n", strerror(errno));
                exit(1);
            }

            close(stage_socket[0]);

            if ( config.mntPid == 0 ) {
                child = fork();
            } else {
                singularity_message(VERBOSE, "Don't execute RPC server, joining instance\n");
                child = 1;
            }
            if ( child == 0 ) {
                singularity_message(VERBOSE, "Spawn RPC server\n");

                close(stage_socket[1]);
                close(rpc_socket[0]);

                if ( mount(NULL, "/", NULL, MS_SLAVE|MS_REC, NULL) < 0 ) {
                    singularity_message(ERROR, "Failed to propagate as SLAVE: %s\n", strerror(errno));
                }

                /* return to host network namespace for network setup */
                singularity_message(DEBUG, "Return to host network namespace\n");
                if ( config.nsFlags & CLONE_NEWNET && (config.nsFlags & CLONE_NEWUSER) == 0 ) {
                    if ( enter_namespace(parent, CLONE_NEWNET) < 0 ) {
                        singularity_message(ERROR, "Failed to return to host network namespace: %s\n", strerror(errno));
                        exit(1);
                    }
                }

                /* Use setfsuid to address issue about root_squash filesystems option */
                if ( config.isSuid ) {
                    if ( setfsuid(uid) != 0 ) {
                        singularity_message(ERROR, "Previous filesystem UID is not equal to 0\n");
                        exit(1);
                    }
                    if ( setfsuid(-1) != uid ) {
                        singularity_message(ERROR, "Failed to set filesystem uid to %d\n", uid);
                        exit(1);
                    }
                }

                free(json_stdin);

                execute = RPC_SERVER;
                return;
            } else if ( child > 0 ) {
                close(rpc_socket[1]);
                prepare_scontainer_stage(2);
                return;
            }
            singularity_message(ERROR, "Failed to execute container\n");
            exit(1);
        } else if ( stage_pid > 0 ) {
            config.containerPid = stage_pid;

            singularity_message(VERBOSE, "Spawn smaster process\n");

            close(stage_socket[1]);

            if ( config.mntPid != 0 ) {
                int status;

                singularity_message(DEBUG, "Wait scontainer stage 2 child process\n");
                waitpid(stage_pid, &status, 0);
                if ( WIFEXITED(status) || WIFSIGNALED(status) ) {
                    singularity_message(VERBOSE, "scontainer stage 2 exited with status %d\n", WEXITSTATUS(status));
                    exit(WEXITSTATUS(status));
                }
                singularity_message(ERROR, "Child exit with unknown status\n");
                exit(1);
            } else {
                singularity_message(VERBOSE, "Create smaster mount namespace\n");
                if ( create_namespace(CLONE_NEWNS) < 0 ) {
                    singularity_message(ERROR, "Failed to create mount namespace: %s\n", strerror(errno));
                    exit(1);
                }
                if ( mount(NULL, "/", NULL, MS_SLAVE|MS_REC, NULL) < 0 ) {
                    singularity_message(ERROR, "Failed to propagate / mount as SLAVE: %s\n", strerror(errno));
                }
                execute = SMASTER;
                return;
            }
        }
        singularity_message(ERROR, "Failed to create container namespaces\n");
        exit(1);
    }
}

int main(int argc, char **argv) {
    (void)argv;
    (void)argc;

    switch(execute) {
    case SCONTAINER_STAGE1:
        singularity_message(VERBOSE, "Execute scontainer stage 1\n");
        SContainer(1, 0, 0, &config, json_stdin);
        break;
    case SCONTAINER_STAGE2:
        singularity_message(VERBOSE, "Execute scontainer stage 2\n");
        SContainer(2, stage_socket[1], rpc_socket[0], &config, json_stdin);
        break;
    case SCONTAINER_STAGE3:
        singularity_message(VERBOSE, "Execute scontainer stage 3\n");
        SContainer(3, stage_socket[1], rpc_socket[0], &config, json_stdin);
        break;
    case SMASTER:
        singularity_message(VERBOSE, "Execute smaster process\n");
        SMaster(stage_socket[0], &config, json_stdin);
        break;
    case RPC_SERVER:
        singularity_message(VERBOSE, "Serve RPC requests\n");
        RPCServer(rpc_socket[1], sruntime);
        break;
    }
    singularity_message(ERROR, "You should not be there\n");
    exit(1);
}
