#!/bin/bash
#
# Copyright (c) 2017, SingularityWare, LLC. All rights reserved.
#
# See the COPYRIGHT.md file at the top-level directory of this distribution and at
# https://github.com/singularityware/singularity/blob/master/COPYRIGHT.md.
#
# This file is part of the Singularity Linux container project. It is subject to the license
# terms in the LICENSE.md file found in the top-level directory of this distribution and
# at https://github.com/singularityware/singularity/blob/master/LICENSE.md. No part
# of Singularity, including this file, may be copied, modified, propagated, or distributed
# except according to the terms contained in the LICENSE.md file.
#
# This file also contains content that is covered under the LBNL/DOE/UC modified
# 3-clause BSD license and is subject to the license terms in the LICENSE-LBNL.md
# file found in the top-level directory of this distribution and at
# https://github.com/singularityware/singularity/blob/master/LICENSE-LBNL.md.


set -u

if [ -z "${SINGULARITY_libexecdir:-}" ]; then
    echo "ERROR: SINGULARITY_libexecdir not defined in environment"
    exit 2
fi

if [ -z "${SINGULARITY_MESSAGELEVEL:-}" ]; then
    echo "Warning: SINGULARITY_MESSAGELEVEL is undefined, temporarily setting to '5' (all messages)"
    SINGULARITY_MESSAGELEVEL=5
fi

if [ -z "${USER:-}" ]; then
    USER=`id -un`
    export USER
fi
if [ -z "${HOME:-}" ]; then
    HOME=`getent passwd "$USER" | cut -d : -f 6`
    export HOME
fi


message() {
    LEVEL="${1:-}"
    MESSAGE="${2:-}"
    if [ -z "$MESSAGE" ]; then
        return 0
    fi
    shift
    shift
    case "$LEVEL" in
        e|error|E|ERROR)
            tput -Txterm setaf 1 2>/dev/null
            printf "ERROR: $MESSAGE" "$@" 1>&2
            tput -Txterm sgr0 2>/dev/null
        ;;
        a|ABORT)
            tput -Txterm setaf 1 2>/dev/null
            printf "ABORT: $MESSAGE" "$@" 1>&2
            tput -Txterm sgr0 2>/dev/null
        ;;
        w|warn|warning|W|WARN|WARNING)
            tput -Txterm setaf 3 2>/dev/null
            printf "WARNING: $MESSAGE" "$@" 1>&2
            tput -Txterm sgr0 2>/dev/null
        ;;
        1|INFO)
            if [ "$LEVEL" -le "$SINGULARITY_MESSAGELEVEL" ]; then
                printf "$MESSAGE" "$@"
            fi
        ;;
        p|P|CHECKPASS|PASS)
            tput -Txterm setaf 2 2>/dev/null
            printf "PASS: $MESSAGE" "$@" 1>&2
            tput -Txterm sgr0 2>/dev/null
        ;;
        NOTIFY|notify)
            tput -Txterm setaf 6 2>/dev/null
            printf "$MESSAGE" "$@" 1>&2
            tput -Txterm sgr0 2>/dev/null
        ;;
        f|F|CHECKFAIL|FAIL)
            tput -Txterm setaf 1 2>/dev/null
            printf "FAIL: $MESSAGE\n" "$@" 1>&2
            tput -Txterm sgr0 2>/dev/null
        ;;
        [2-5]|VERBOSE|DEBUG)
            if [ "$LEVEL" -le "$SINGULARITY_MESSAGELEVEL" ]; then
                printf "$MESSAGE" "$@" 1>&2
            fi
        ;;
    esac

    return 0
}


singularity_key_get() {
    KEY="${1:-}"
    FILE="${2:-}"
    if OUT=`egrep -i "^$KEY:" $FILE`; then
        echo "$OUT" | head -n 1 | sed -e "s@^$KEY:\s*@@i" | sed -e "s@\s*#.*@@"
        return 0
    fi
    return 1
}


singularity_keys_get() {
    KEY="${1:-}"
    FILE="${2:-}"
    egrep -i "^$KEY:" "$FILE" | while read i; do
        echo "$i" | sed -e "s@^$KEY:\s*@@i" | sed -e "s@\s*#.*@@"
    done | tr '\n' ' '
    echo

    return 0
}


##############################################################################
# SECTIONS
##############################################################################


singularity_section_exists() {
    SECTION="${1:-}"
    FILE="${2:-}"
    TOGGLE=""
    if [ ! -f "$FILE" ]; then
        message ERROR "File not found ($FILE)\n"
        exit 1
    fi
    if ! egrep -i -q -- "^%$SECTION\W*" "$FILE"; then
        return 1
    fi

    return 0
}


singularity_section_args() {
    SECTION="${1:-}"
    FILE="${2:-}"
    TOGGLE=""
    if [ ! -f "$FILE" ]; then
        message ERROR "File not found ($FILE)\n"
        exit 1
    fi

    egrep -i -- "^%$SECTION\W*" "$FILE" | sed -e "s@%$SECTION\s*@@i"

    return 0
}

singularity_section_get() {
    SECTION="${1:-}"
    FILE="${2:-}"
    if [ ! -x "$SINGULARITY_libexecdir/singularity/bin/get-section" ]; then
        message ERROR "Could not locate get-section program\n"
        exit 255
    fi

    if [ ! -f "$FILE" ]; then
        message ERROR "File not found ($FILE)\n"
        exit 1
    fi

    eval "$SINGULARITY_libexecdir/singularity/bin/get-section" "$SECTION" "$FILE"

    return 0
}

singularity_daemon_glob() {
    if ! USERID=`id --real --user`; then
        message ERROR "Could not ascertain user ID\n"
        exit 255
    fi

    HOST=`hostname`
    HOME=`getent passwd ${USERID} | cut -d: -f6`

    # This is a configurable option, needs to be set accordingly!
    SINGULARITY_DAEMON_GLOB="${HOME}/.singularity/daemon/${HOST}/*"
    echo $SINGULARITY_DAEMON_GLOB
    return 0
}

singularity_daemon_file() {
    if ! USERID=`id --real --user`; then
        message ERROR "Could not ascertain user ID\n"
        exit 255
    fi
    
    HOST=`hostname`
    HOME=`getent passwd ${USERID} | cut -d: -f6`
    DEVINO=`stat --format=%d.%i ${SINGULARITY_IMAGE}`

    # This is a configurable option, needs to be set accordingly!
    SINGULARITY_DAEMON_FILE="${HOME}/.singularity/daemon/${HOST}/${DEVINO}-${SINGULARITY_DAEMON_NAME}"
    echo $SINGULARITY_DAEMON_FILE
    return 0
}

singularity_calculate_size() {
    FOLDER="${1:-}"
    if [ ! -d "${FOLDER}" ]; then
        message ERROR "Folder not found ($FOLDER)\n"
    fi

    eval du -sm ${FOLDER} | cut -f1 # MB

    return 0
}


##############################################################################
# APPS
##############################################################################


singularity_app_install_get() {
    APPNAME="${1:-}"
    FILE="${2:-}"
    
    if [ ! -x "$SINGULARITY_libexecdir/singularity/bin/get-section" ]; then
        message ERROR "Could not locate get-section program\n"
        exit 255
    fi

    if [ ! -f "$FILE" ]; then
        message ERROR "File not found ($FILE)\n"
        exit 1
    fi

    # To install application, much change to its base and back so paths are relative
    SECTION="'appinstall ${APPNAME}'"
    printf "cd /scif/apps/${APPNAME}\n"
    eval $SINGULARITY_libexecdir/singularity/bin/get-section "$SECTION" "$FILE"
    return 0
}


singularity_app_save() {
    APPNAME="${1:-}"
    FILE="${2:-}"
    OUTPUT_FILE="${3:-}"
    
    if [ ! -x "$SINGULARITY_libexecdir/singularity/bin/get-section" ]; then
        message ERROR "Could not locate get-section program\n"
        exit 255
    fi

    if [ ! -f "$FILE" ]; then
        message ERROR "File not found ($FILE)\n"
        exit 1
    fi

    SECTION_FOUND="No"
    while read line
    do
        if [[ "$line" == "%appinstall $APPNAME" ]]; then # start of section
            echo "$line" >> $OUTPUT_FILE
            SECTION_FOUND="Yes"
        elif [[ "$line" == %* ]]; then                   # end of section
            if [[ "$SECTION_FOUND" == "Yes" ]]; then
                return 0
            fi
        else
            if [[ "$SECTION_FOUND" == "Yes" ]]; then
                echo "$line" >> $OUTPUT_FILE             # line in section
            fi
        fi
    done < "$FILE"
    return 0
}


singularity_app_init() {

    APPNAME="${1:-}"
    APPROOT="${2:-}"

    APPBASE="${APPROOT}/scif/apps/${APPNAME}"
    if [ ! -d "${APPBASE}" ]; then
        mkdir -p "${APPBASE}/scif"
        message 2 "Creating ${APPBASE}...\n"
    fi

    APPDATA="${APPROOT}/scif/data/${APPNAME}"
    if [ ! -d "${APPDATA}" ]; then
        mkdir -p ${APPDATA}
        mkdir -p "${APPDATA}/input"
        mkdir -p "${APPDATA}/output"
        message 2 "Creating ${APPDATA}...\n"
    fi

}


ABORT() {
    RETVAL="${1:-}"
    if [ -z "$RETVAL" ]; then
        RETVAL=1
    fi
    message ABORT "Aborting with RETVAL=$RETVAL\n"
    exit $RETVAL
}

check_pattern() {
    STRING="${1:-}"
    PATTERN="${2:-}"
    case "$PATTERN" in
        $STRING)
            true
        ;;
        *)
            return 1
        ;;
    esac
    return 0
}

cmd() {
    message 2 " + %-68.68s" "$*"
    "$@" >/dev/null 2>&1
    RETVAL=$?
    if [ $RETVAL -eq 0 ]; then
        message 2 "OK\n"
    else
        message 2 "ERROR\n"
    fi
    return $RETVAL
}

eval_abort() {
    eval "$@"
    RETVAL=$?
    if [ $RETVAL -ne 0 ]; then
        exit $RETVAL
    fi
    return 0
}

stest() {
    ERROR="${1:-}"
    TMPFILE=`mktemp`
    shift
    message 2 " + %-80.80s " "$*"
    "$@" >$TMPFILE 2>&1
    CODE="$?"
    if [ "$ERROR" = "0" -a "$CODE" != "0" ]; then
        message 2 "%13s ERROR\n" "(retval=$CODE)"
        tail "$TMPFILE"
        echo "Full output in: $TMPFILE"
        exit 1
    elif [ "$ERROR" != "0" -a "$CODE" = "0" ]; then
        message 2 "%13s ERROR\n" "(retval=$CODE)"
        tail "$TMPFILE"
        echo "Full output in: $TMPFILE"
        exit 1
    else
        message 2 "%13s OK\n" "(retval=$CODE)"
    fi
    rm -f "$TMPFILE"
}


singularity_import() {
    MOD="${1:-}"
    if [ -z "$SINGULARITY_libexecdir" ]; then
        message ERROR "libexecdir not defined, are you running this from within Singularity?\n"
        exit 1
    fi
    if [ -f "$SINGULARITY_libexecdir/singularity/mods/$MOD.smod" ]; then
        . "$SINGULARITY_libexecdir/singularity/mods/$MOD.smod"
    else
        message ERROR "Could not load Singularity module: $MOD\n"
        exit 255
    fi
    return 0
}


# Different versions of which respond differently (print aliases, or take
# different arguments)
singularity_which() {
    i="${1:-}"
    # Avoid non-pathnames with . not in path, and directories
    case $i in
        .* | /*)
            if [ -f "$i" -a -x "$i" ]; then
                echo "$i"
                return 0
            fi
    esac
    for p in `echo $PATH | sed -e 's/:/ /g'`; do
        if [ -f "$p/$i" -a -x "$p/$i" ]; then
            echo "$p/$i"
            return 0
        fi
    done
    return 1
}


parse_opts() {
    NEWOPTS=""
    while [ -n "${1:-}" ]; do
        case "${1:-}" in
            -*=*)
                ARG1=`echo -n "${1:-}" | cut -d = -f 1`
                ARG2=`echo -n "${1:-}" | cut -d = -f 2`
                NEWOPTS="$NEWOPTS \"$ARG1\" \"$ARG2\""
                shift
                continue
            ;;
            --*)
                NEWOPTS="$NEWOPTS \"${1:-}\""
                shift
                continue
            ;;
            -*)
                for o in `echo "${1:-}"| sed 's/^-//' | sed 's/./-& /g'`; do
                    NEWOPTS="$NEWOPTS \"$o\""
                done
                shift
                continue
            ;;
            *)
                NEWOPTS="$NEWOPTS $@"
                break
            ;;
        esac
    done
    # Eww, this is bad I know... Would be better just to pass the variable
    # around without making ad-hoc modifications... Got a better idea, let
    # me know! (gmk)
    echo "$NEWOPTS" | sed -e 's/\\/\\\\/g'
}


compare_envs() {
    # during bootstrap, if we are bootstrapping from a local image, compare the
    # environment in the new image to that in the old image and alert the user
    # of any changes
    REMOVED=$(comm -23 ${SINGULARITY_STARTING_ENVIRONMENT} ${SINGULARITY_ENDING_ENVIRONMENT})
    ADDED=$(comm -13 ${SINGULARITY_STARTING_ENVIRONMENT} ${SINGULARITY_ENDING_ENVIRONMENT})
     
    if [ -n "${REMOVED:-}" -o -n "${ADDED:-}" ]; then
        message 1 "Environment variables were added, removed, and/or changed during bootstrap.\n"
    elif [ "${SINGULARITY_STARTING_ENVSHA1:-}" != "${SINGULARITY_ENDING_ENVSHA1:-}" ]; then
        message 1 "The environment of ${SINGULARITY_IMAGE} may differ from the environment of ${FROM}\n"
        message 1 "${FROM} sha1 sum of environment is ${SINGULARITY_STARTING_ENVSHA1}\n"
        message 1 "${SINGULARITY_IMAGE} sha1 sum of environment is ${SINGULARITY_ENDING_ENVSHA1}\n"
    fi
    if [ -n "${REMOVED:-}" ]; then
        message 1 "Variables unique to original image (${FROM})\n"
        message 1 "$REMOVED\n"
    fi
    if [ -n "${ADDED:-}" ]; then
        message 1 "Variables unique to new image (${SINGULARITY_IMAGE})\n"
        message 1 "$ADDED\n"
    fi
}


replace_string() {
   ORIGINAL="${1:-}"
   MATCH="${2:-}"
   REPLACE="${3:-}"
   echo $ORIGINAL | sed -e s/${MATCH}/${REPLACE}/g
}


##############################################################################
# CHECKS
##############################################################################


# Given a script and an assigned level and tag, determine if it should be
# executed to perform the check
# [LEVEL] [SCRIPT] [TAGS]

exec_check() {
    CHECKSUCCESS="${1:-}"
    CHECKLEVEL="${2:-}"
    CHECKSCRIPT="${3:-}"
    shift
    shift
    shift
    CHECKTAGS="${@}"

    # The default case is that we don't run
    RETVAL=0  

    # Don't perform check if tag not indicated
    PERFORM_CHECK=1

    # if not "all," check if user wants check performed
    if [ "$SINGULARITY_CHECKTAGS" != "all" ]; then
        has_tag "$CHECKTAGS" "$SINGULARITY_CHECKTAGS" || PERFORM_CHECK=0
    fi

    if [ $PERFORM_CHECK -eq 0 ]; then
        return $RETVAL
    fi
 
    RUNCHECK_LEVEL=3        # Perform all checks
    case "$CHECKLEVEL" in
        l|low|L|LOW)
            RUNCHECK_LEVEL=3
        ;;
        m|med|M|MED)
            RUNCHECK_LEVEL=2
        ;;
        h|high|H|HIGH)
            RUNCHECK_LEVEL=1
        ;;
    esac

    if [ "$RUNCHECK_LEVEL" -le "$SINGULARITY_CHECKLEVEL" ]; then
       message NOTIFY "START ${CHECKSCRIPT##*/} tags[${CHECKTAGS}] level[$CHECKLEVEL]\n"
       scheck 0 $CHECKSCRIPT # script must have interpreter specified
       printf " $CHECKSCRIPT \n"
    fi

    return $RETVAL
}


has_tag() {

    taglist="$1"
    tag="$2"
    if test "${taglist#*$tag}" != "$taglist"
    then
        return 0 # has tag, perform test
    else
        return 1 # no tag, skip test
    fi
}


scheck() {
    ERROR="${1:-}"
    shift
    message 2 " + %-80.80s " "$*"
    "$@"
    CODE="$?"
    if [ "$ERROR" = "0" -a "$CODE" != "0" ]; then
        message FAIL "(retval=$CODE)"
    elif [ "$ERROR" != "0" -a "$CODE" = "0" ]; then
        message FAIL "(retval=$CODE)"
    else
        message PASS "(retval=$CODE)"
    fi
    return $CODE
}

if [ -n "${SHELL_DEBUG:-}" ]; then
    set -x
fi
