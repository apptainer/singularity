# generic functions

fatal() {
    test-error "$1"
    exit 1
}

# test if singularity binary is present in $PATH
if ! command -v singularity >/dev/null 2>&1; then
    fatal "singularity executable not found in \$PATH"
fi

# execute/test commands interactively
_uuid=`uuidgen`
_script="${TESTDIR}/${_uuid}.script"
_cmdline="${TESTDIR}/${_uuid}.cmdline"

_check-script() {
    if [ ! -f ${_script} ]; then
        fatal "interactive function not used between start-interactive and exit-interactive calls"
    fi
}

start-interactive() {
    name=$1
    shift
    echo -n > ${_script}
    echo "${name} ${_script} $@" > ${_cmdline}
}

interactive-send() {
    _check-script
    echo "send $1" >> ${_script}
}

interactive-expect() {
    _check-script
    echo "expect $1" >> ${_script}
}

interactive-sendline() {
    _check-script
    echo "sendline $1" >> ${_script}
}

interactive-ctrl-c() {
    _check-script
    interactive-send $'\x03'
}

interactive-ctrl-d() {
    _check-script
    interactive-send $'\x04'
}

interactive-eof() {
    _check-script
    interactive-expect "<EOF>"
}

exit-interactive() {
    if [ $# != 1 ]; then
        fatal "exit-interactive need an exit code argument"
    fi
    if [ ! -f ${_script} ]; then
        fatal "no interactive script provided"
    fi
    if [ ! -f ${_cmdline} ]; then
        fatal "no command line provided in start-interactive"
    fi
    expect-exit-interactive $1 `cat ${_cmdline}`
    rm -f ${_script}
    rm -f ${_cmdline}
}

# wrapper around default test builtin
expect-failure() {
    expect-exit 1 "$@"
}

expect-success() {
    expect-exit 0 "$@"
}

stdout-contains() {
    test_name="$1"
    pattern="$2"
    shift
    shift
    expect-search output "${pattern}" "${test_name}" "$@" >>/tmp/cmd.output 2>&1
}

stderr-contains() {
    test_name="$1"
    pattern="$2"
    shift
    shift
    expect-search error "${pattern}" "${test_name}" "$@" >>/tmp/cmd.output 2>&1
}

stdall-contains() {
    test_name="$1"
    pattern="$2"
    shift
    shift
    expect-search combined "${pattern}" "${test_name}" "$@" >>/tmp/cmd.output 2>&1
}

test-match() {
    expect-exit 0 $1 /bin/sh -c "[ \"$2\" = \"$3\" ]"
}

# manage test file/directory
mktmpdir() {
    create-tmpdir ${TESTDIR}
}

mktmpfile() {
    create-tmpfile ${TESTDIR}
}

# test image
get-test-image() {
    image="${TESTDIR}/test.sif"

    if [ ! -f "${image}" ]; then
        definition="${SOURCEDIR}/e2e/testdata/Singularity"
        sudo singularity build -F ${image} ${definition} >${TESTDIR}/image.out 2>&1
        if [ $? != 0 ]; then
            output=`cat ${TESTDIR}/image.out`
            fatal "failed to build image ${image}: ${output}"
        fi
    fi

    echo ${image}
}

verify-image() {
    if [ $? = 0 ]; then
        name="$1"
        image="$2"
        expect-exit 1 "${name}/False"        singularity exec ${image} false
        expect-exit 0 "${name}/RunScript"    singularity exec ${image} test -f /.singularity.d/runscript
        expect-exit 0 "${name}/OneBase"      singularity exec ${image} test -f /.singularity.d/env/01-base.sh
        expect-exit 0 "${name}/ActionsShell" singularity exec ${image} test -f /.singularity.d/actions/shell
        expect-exit 0 "${name}/ActionsExec"  singularity exec ${image} test -f /.singularity.d/actions/exec
        expect-exit 0 "${name}/ActionsRun"   singularity exec ${image} test -f /.singularity.d/actions/run
        expect-exit 0 "${name}/Environment"  singularity exec ${image} test -L /environment
        expect-exit 0 "${name}/Singularity"  singularity exec ${image} test -L /singularity
    fi
}

check-command() {
    if ! command -v $1 >/dev/null 2>&1; then
        test-skip-script "$1 command not found in PATH"
    fi
}

check-overlayfs() {
    sudo modprobe overlay >/dev/null 2>&1
    check-fs overlay
    if [ $? != 0 ]; then
        test-skip-script "overlay filesystem seems not supported"
    fi
}

run-command() {
    $@ >${TESTDIR}/run-command.out 2>&1
    if [ $? != 0 ]; then
        output=`cat ${TESTDIR}/run-command.out`
        fatal "$@ failed: ${output}"
    fi
}

check-kernel-version() {
    kernel_version=`uname -r`
    kernel_version=${kernel_version%%-*}
    check-version "${kernel_version}" "$1"
}

# create sudo wrapper to pass correct environment variables to singularity
bindir="${TESTDIR}/bin"
sudo_wrapper="${bindir}/sudo"

if [ ! -f "${sudo_wrapper}" ]; then
    mkdir "${bindir}"
    cat > "${sudo_wrapper}" <<EOF
#!/bin/sh
exec ${SUDO} HOME=/root SINGULARITY_CACHEDIR=${CACHEDIR_PRIV} PATH=${PATH} "\$@"
EOF
    chmod 755 "${sudo_wrapper}"
fi

export PATH=${bindir}:${PATH}