######################################################################
# common test functions
######################################################################

######################################################################
# fatal trigger a test error message and exit script with code 1.
######################################################################
fatal() {
    local message="$1"
    test-error "${message}"
    exit 1
}

######################################################################
# test if singularity binary is present in $PATH.
######################################################################
if ! command -v singularity >/dev/null 2>&1; then
    fatal "singularity executable not found in \$PATH"
fi

######################################################################
# create script temporary test directory
######################################################################
declare -r -x SCRIPT_TESTDIR=`create-tmpdir ${TESTDIR}`
chmod 0755 ${SCRIPT_TESTDIR}

######################################################################
# this function will be called at script exit to delete all temporary
# directories and files created by the running script.
######################################################################
_cleanup_tmp() {
    sudo rm -rf "${SCRIPT_TESTDIR}"
}
register-exit-func _cleanup_tmp

######################################################################
# execute/test commands interactively
######################################################################
declare -r _script="${SCRIPT_TESTDIR}/interactive.script"
declare -r _cmdline="${SCRIPT_TESTDIR}/interactive.cmdline"

######################################################################
# this function ensure interactive-XXX functions are not called
# outside of start-interactive and exit-interactive calls.
######################################################################
_check-script() {
    if [ ! -f ${_script} ]; then
        fatal "interactive function not used between start-interactive and exit-interactive calls"
    fi
}

######################################################################
# start-interactive prepare interactive command execution and must be
# called before any interactive-XXX calls.
######################################################################
start-interactive() {
    local name="$1"
    shift
    echo -n > ${_script}
    echo "${name} ${_script} $@" > ${_cmdline}
}

######################################################################
# interactive-send sends the provided string to the command input
# (equivalent to type a string without hitting ENTER)
######################################################################
interactive-send() {
    _check-script
    local str="$1"
    echo "send ${str}" >> ${_script}
}

######################################################################
# interactive-sendline sends the provided string to the command input
# (equivalent to type a string followed by ENTER).
######################################################################
interactive-sendline() {
    _check-script
    local str="$1"
    echo "sendline ${str}" >> ${_script}
}

######################################################################
# interactive-expect expect to read the provided string from the
# command execution output.
######################################################################
interactive-expect() {
    _check-script
    local expect="$1"
    echo "expect ${expect}" >> ${_script}
}

######################################################################
# interactive-ctrl-c sends CTRL+C characters to the command input.
######################################################################
interactive-ctrl-c() {
    _check-script
    interactive-send $'\x03'
}

######################################################################
# interactive-ctrl-d sends CTRL+D characters to the command input.
######################################################################
interactive-ctrl-d() {
    _check-script
    interactive-send $'\x04'
}

######################################################################
# interactive-eof waits that command execution finishes.
######################################################################
interactive-eof() {
    _check-script
    interactive-expect "<EOF>"
}

######################################################################
# exit-interactive waits that command execution finishes.
######################################################################
exit-interactive() {
    local exit_code="$1"

    if [ $# != 1 ]; then
        fatal "exit-interactive need an exit code argument"
    fi
    if [ ! -f ${_script} ]; then
        fatal "no interactive script provided"
    fi
    if [ ! -f ${_cmdline} ]; then
        fatal "no command line provided in start-interactive"
    fi
    expect-exit-interactive ${exit_code} `cat ${_cmdline}`
    rm -f ${_script}
    rm -f ${_cmdline}
}

######################################################################
# expect-failure executes a command with test builtin expect-exit and
# checks if exit code is equal to 1, if exit is not 1 the test fail.
######################################################################
expect-failure() {
    expect-exit 1 "$@"
}

######################################################################
# expect-failure executes a command with test builtin expect-exit and
# checks if exit code is equal to 0, if exit is not 0 the test fail.
######################################################################
expect-success() {
    expect-exit 0 "$@"
}

######################################################################
# stdout-contains executes a command with test builtin expect-search
# and checks if command output stream contains the provided pattern,
# if the pattern is not found the test fail.
# NOTE: prefixing pattern with "regex:" allows to provides regular
# expression
######################################################################
stdout-contains() {
    local test_name="$1"
    local pattern="$2"
    shift
    shift
    expect-search output "${pattern}" "${test_name}" "$@"
}

######################################################################
# stderr-contains executes a command with test builtin expect-search
# and checks if command error stream contains the provided pattern,
# if the pattern is not found the test fail.
# NOTE: prefixing pattern with "regex:" allows to provides regular
# expression
######################################################################
stderr-contains() {
    local test_name="$1"
    local pattern="$2"
    shift
    shift
    expect-search error "${pattern}" "${test_name}" "$@"
}

######################################################################
# stdall-contains executes a command with test builtin expect-search
# and checks if command output/error streams contains the provided
# pattern, if the pattern is not found the test fail.
# NOTE: prefixing pattern with "regex:" allows to provides regular
# expression
######################################################################
stdall-contains() {
    local test_name="$1"
    local pattern="$2"
    shift
    shift
    expect-search combined "${pattern}" "${test_name}" "$@"
}

######################################################################
# test-match tests if two strings are identical
######################################################################
test-match() {
    local test_name="$1"
    expect-exit 0 "${test_name}" /bin/sh -c "[ \"$2\" = \"$3\" ]"
}

######################################################################
# mktmpdir creates a temporary directory in $SCRIPT_TESTDIR,
# directories created with mktmpdir are automatically deleted when
# script exit.
######################################################################
mktmpdir() {
    local mode="$1"
    local owner="$2"

    if [ -z ${mode} ]; then
        mode="0700"
    fi

    local dir=`create-tmpdir ${SCRIPT_TESTDIR}`
    chmod ${mode} ${dir}
    if [ ! -z ${owner} ]; then
        sudo chown ${owner} ${dir}
    fi

    echo ${dir}
}

######################################################################
# mktmpfile creates a temporary file in $SCRIPT_TESTDIR, files created
# with mktmpfile are automatically deleted when script exit.
######################################################################
mktmpfile() {
    local mode="$1"
    local owner="$2"

    if [ -z ${mode} ]; then
        mode="0700"
    fi

    local file=`create-tmpfile ${SCRIPT_TESTDIR}`
    chmod ${mode} ${file}
    if [ ! -z ${owner} ]; then
        sudo chown ${owner} ${dir}
    fi

    echo ${file}
}

######################################################################
# get-test-image returns the path to the test image, if the image
# doesn't already exists, it build the test image and returns the
# path.
# NOTE: The test image is not deleted until all scripts are executed
######################################################################
get-test-image() {
    local image="${TESTDIR}/test.sif"

    flock lock "${TESTDIR}"

    if [ ! -f "${image}" ]; then
        local definition="${SOURCEDIR}/e2e/testdata/Singularity"
        sudo singularity build -F ${image} ${definition} >${TESTDIR}/image.out 2>&1
        if [ $? != 0 ]; then
            local output=`cat ${TESTDIR}/image.out`
            fatal "failed to build image ${image}: ${output}"
        fi
    fi

    flock unlock "${TESTDIR}"

    echo ${image}
}

######################################################################
# verify-image executes a test suite to verify that a freshly builded
# image is valid.
# NOTE: Must be called just after a call to "expect-success" or
# "expect-exit 0"
######################################################################
verify-image() {
    if [ $? = 0 ]; then
        local name="$1"
        local image="$2"
        expect-exit 1 "${name}/False"        singularity exec "${image}" false
        expect-exit 0 "${name}/RunScript"    singularity exec "${image}" test -f /.singularity.d/runscript
        expect-exit 0 "${name}/OneBase"      singularity exec "${image}" test -f /.singularity.d/env/01-base.sh
        expect-exit 0 "${name}/ActionsShell" singularity exec "${image}" test -f /.singularity.d/actions/shell
        expect-exit 0 "${name}/ActionsExec"  singularity exec "${image}" test -f /.singularity.d/actions/exec
        expect-exit 0 "${name}/ActionsRun"   singularity exec "${image}" test -f /.singularity.d/actions/run
        expect-exit 0 "${name}/Environment"  singularity exec "${image}" test -L /environment
        expect-exit 0 "${name}/Singularity"  singularity exec "${image}" test -L /singularity
    fi
}

######################################################################
# build-verify-image builds and verify image.
######################################################################
build-verify-image() {
    local image_type="$1"
    local test_name="$2"
    local check_binary="$3"
    local build_source="$4"

    local options=""
    local img=""

    case "${image_type}" in
    sandbox)
        options="-s"
        img=`mktmpdir`
        ;;
    image)
        img=`mktmpfile`
        ;;
    *)
        test-log "image type ${image_type} not supported"
        return
        ;;
    esac

    if [ "${check_binary}" != "" ]; then
        if ! command -v ${check_binary} >/dev/null 2>&1; then
            test-skip "${test_name}" "${check_binary} command not found"
            return
        fi
    fi
    expect-exit 0 "${test_name}" sudo singularity build -F ${options} "${img}" "${build_source}"
    verify-image "${test_name}" "${img}"
}

######################################################################
# check-command checks that the provided command is in $PATH. If
# the command is not found, the script execution is interrupted and
# test is marked as skipped.
# NOTE: this function should be called at the beginning of script
# before creating temporary files or directories or building image
######################################################################
check-command() {
    local cmd="$1"
    if ! command -v ${cmd} >/dev/null 2>&1; then
        test-skip-script "${cmd} command not found in PATH"
    fi
}

######################################################################
# check-overlayfs checks that overlay filesystem is supported. If
# not, the script execution is interrupted and test is marked as
# skipped.
# NOTE: this function should be called at the beginning of script
######################################################################
check-overlayfs() {
    sudo modprobe overlay >/dev/null 2>&1
    check-fs overlay
    if [ $? != 0 ]; then
        test-skip-script "overlay filesystem seems not supported"
    fi
}

######################################################################
# run-command executes a command and trigger a fatal error if the
# command didn't succeed.
######################################################################
run-command() {
    $@ >${SCRIPT_TESTDIR}/run-command.out 2>&1
    if [ $? != 0 ]; then
        local output=`cat ${SCRIPT_TESTDIR}/run-command.out`
        fatal "$@ failed:\\n${output}"
    fi
}

######################################################################
# check-kernel-version compare current kernel version to range
# provided as argument.
# NOTE: please refer to https://github.com/blang/semver#ranges to
# see supported ranges as argument
######################################################################
check-kernel-version() {
    local range="$1"
    local kernel_version=`uname -r`
    kernel_version=${kernel_version%%-*}
    check-version "${kernel_version}" "${range}"
}

######################################################################
# process-template-data executes a command and trigger a fatal error if the
# command didn't succeed.
######################################################################
process-template-data() {
    local _template="${1:-}"
    local _test_table="${2:-}"
    local _custom_func="${3:-}"
    local _func_vars="${4:-func_vars}"
    local _template_data="${5:-template_data}"

    if [ -z "${_template}" ]; then
        fatal "test-template-data: no template argument provided"
    fi

    if [ -z "${_custom_func}" ]; then
        fatal "test-template-data: no custom function provided"
    fi

    local _test_table_tpl='{{range $k, $test := .}}{{printf "%s>%s\n" $k (marshal $test)}}{{end}}'
    local _tests=$(execute-template "${_test_table_tpl}" "${_test_table}")
    if [ -z "${_tests}" ]; then
        test-error "test-template-data: no test found"
    fi

    local IFS_ORIG="$IFS"
    IFS=$'\n'

    for i in ${_tests}; do
        name=${i%%>*}
        json=${i#*>}
        data=`echo "${json}" | execute-template '{{marshal .'${_template_data}'}}' | execute-template "${_template}"`
        if [ -z "${data}" ]; then
            test-skip "${name}" "no template data found"
        fi
        local _vars=$(cat <<-EOF
            get-var-string() {
                echo "\$json" | execute-template '{{if .'${_func_vars}'.'\$1'}}{{.'${_func_vars}'.'\$1'}}{{end}}'
            }
            get-var-list() {
                tpl='{{if .'${_func_vars}'.'\$1'}}{{range \$e := .'${_func_vars}'.'\$1'}}{{printf "%s\n" \$e}}{{end}}{{end}}'
                echo "\$json" | execute-template "\$tpl"
            };
EOF
        )
        (eval "IFS="${IFS_ORIG}"; ${_vars} ${_custom_func}")
    done

    IFS="${IFS_ORIG}"
}

######################################################################
# create cache directories for privileged/unprivileged users, those
# directories are not shared between scripts
######################################################################
declare -r -x SINGULARITY_CACHEDIR=`mktmpdir 0755`
declare -r -x SINGULARITY_CACHEDIR_PRIV=`mktmpdir 0755 root:root`

######################################################################
# create sudo wrapper to pass correct environment variables
# to singularity.
######################################################################
bindir="${SCRIPT_TESTDIR}/bin"
sudo_wrapper="${bindir}/sudo"

if [ ! -f "${sudo_wrapper}" ]; then
    mkdir "${bindir}"
    cat > "${sudo_wrapper}" <<EOF
#!/bin/sh
exec ${SUDO} SINGULARITY_CACHEDIR="${SINGULARITY_CACHEDIR_PRIV}" PATH=${PATH} "\$@"
EOF
    chmod 755 "${sudo_wrapper}"
fi

export PATH=${bindir}:${PATH}